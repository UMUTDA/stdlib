! SPDX-Identifier: MIT

! #:include "common.fypp"
! #:set RANKS = range(1, MAXRANK + 1)
! #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES

!> Implementation of loading uncompressed and compressed npz files into multidimensional arrays.
submodule(stdlib_io_np) stdlib_io_npz_load
    use stdlib_error, only: error_stop
    use stdlib_string_type, only: string_type
    use stdlib_io_zip, only: unzip, zip_prefix, zip_suffix, raw_file
    implicit none

contains

    !> Version: experimental
    !>
    !> Load multidimensional arrays from a compressed or uncompressed npz file.
    !> ([Specification](../page/specs/stdlib_io.html#load_npz))
    module subroutine load_npz_to_bundle(filename, bundle, iostat, iomsg)
        character(len=*), intent(in) :: filename
        type(t_array_bundle), intent(out) :: bundle
        integer, intent(out), optional :: iostat
        character(len=:), allocatable, intent(out), optional :: iomsg
        
        logical :: exists
        integer :: io_unit, stat
        character(len=:), allocatable :: msg
        type(raw_file), allocatable :: raw_files(:)

        call unzip(filename, raw_files, stat, msg)
        if (stat /= 0) then
            call identify_problem(filename, stat, msg)
        end if

        if (present(iostat)) then
            iostat = stat
        else if (stat /= 0) then
            if (allocated(msg)) then
                call error_stop("Failed to read arrays from file '"//filename//"'"//nl//msg)
            else
                call error_stop("Failed to read arrays from file '"//filename//"'")
            end if
        end if

        if (present(iomsg) .and. allocated(msg)) call move_alloc(msg, iomsg)
    end

    !> Open file and try to identify the problem.
    module subroutine identify_problem(filename, stat, msg)
        character(len=*), intent(in) :: filename
        integer, intent(inout) :: stat
        character(len=:), allocatable, intent(inout) :: msg

        logical :: exists
        integer :: io_unit, prev_stat
        character(len=:), allocatable :: prev_msg

        ! Keep track of the previous status and message in case no reason can be found.
        prev_stat = stat
        if (allocated(msg)) call move_alloc(msg, prev_msg)

        inquire (file=filename, exist=exists)
        if (.not. exists) then
            stat = 1; msg = 'File does not exist: '//filename//'.'; return
        end if
        open (newunit=io_unit, file=filename, form='unformatted', access='stream', &
            & status='old', action='read', iostat=stat, iomsg=msg)
        if (stat /= 0) return

        call verify_header(io_unit, stat, msg)
        if (stat /= 0) return

        ! Restore previous status and message if no reason could be found.
        stat = prev_stat; msg = 'Failed to unzip file: '//filename//nl//prev_msg
    end

    module subroutine verify_header(io_unit, stat, msg)
        integer, intent(in) :: io_unit
        integer, intent(out) :: stat
        character(len=:), allocatable, intent(out) :: msg

        integer :: file_size
        character(len=len(zip_prefix)) :: header

        inquire (io_unit, size=file_size)
        if (file_size < len(zip_suffix)) then
            stat = 1; msg = 'File is too small to be an npz file.'; return
        end if

        read (io_unit, iostat=stat) header
        if (stat /= 0) then
            msg = 'Failed to read header from file'; return
        end if

        if (header == zip_suffix) then
            stat = 1; msg = 'Empty npz file.'; return
        end if

        if (header /= zip_prefix) then
            stat = 1; msg = 'Not an npz file.'; return
        end if
    end

end
